# Заметки по RxJS

- **Observable** — ленивый источник значений во времени, который описывает поток, но не выполняется, пока к нему не подпишутся.
- **Observer** — объект-подписчик с методами `next`, `error`, `complete`, реагирующий на значения из observable.
- **Subscription** — результат `observable.subscribe(...)`, управляющий активным выполнением и позволяющий его остановить через `unsubscribe()`.

`map` vs `switchMap`:
- `map` синхронно преобразует каждое исходное значение и сохраняет структуру исходного потока.
- `switchMap` превращает каждое значение в новый observable, подписывается только на самый свежий и отписывается от предыдущих.

Типичные ошибки новичков:
- Не отписываются от долгоживущих потоков (интервалы, DOM-события), что ведёт к утечкам памяти.
- Смешивают «холодные» и «горячие» observable, не понимая различий в разделении выполнения.
- Вкладывают подписки друг в друга вместо композиции операторов, из-за чего теряют контроль над отменой и ошибками.
- Ожидают, что `switchMap` накапливает результаты; он оставляет только поток последнего внутреннего observable.

Следующие шаги:
- Интегрировать RxJS в React через `useEffect` и `useState`, оформив подписки и очистку корректно.
- Изучить Redux Observable для связывания потоков действий и побочных эффектов в более сложных приложениях.

## Интеграция RxJS + React (мини-поиск)

- Источник: `Subject` в `useMemo` создаёт поток значений из поля ввода.
- Управление жизненным циклом: `useEffect` подписывается на пайплайн и отписывается при размонтировании.
- Пайплайн: `trim → debounceTime(300) → distinctUntilChanged → switchMap(fakeSearch)` с промежуточным `startWith('loading')` и обработкой ошибок через `catchError`.
- Отображение: React хранит снэпшот состояния (`status`, `results`, `query`) и историю запросов в `useState`.
- История: добавляем только уникальные успешные запросы, ограничиваем массив пятью элементами.
- UI: статусные бэйджи и списки обновляются реактивно, обеспечивая прозрачную визуализацию потоков в SPA.
